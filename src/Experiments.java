import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

import java.util.ArrayList;
import java.util.Collections;

public class Experiments {

    static final int size = 10000;
    static final int repetitions = 100;


    /**
     * The lists are generated iteratively using an constant level of increasing disorderedness.
     * For each list the sort is completed 100 times to get a more accurate value.
     * The time to complete the quicksort and the worked out metric for ths list is then wrote to a csv file.
     * @param args
     */
    public static void main(String[] args){

        Experiments exp = new Experiments();
        Quicksort qSort = new Quicksort();

        double value = 0.0;

        try {

            FileWriter fW = new FileWriter("data/metric1.csv");
            PrintWriter pW = new PrintWriter(fW);
            FileWriter fW2 = new FileWriter("data/metric2.csv");
            PrintWriter pW2 = new PrintWriter(fW2);
            FileWriter fW3 = new FileWriter("data/both_averages.csv");
            PrintWriter pW3 = new PrintWriter(fW3);

            pW.println("pairs_out_of_order,duration_ns");
            pW2.println("difference_in_position_coefficient,duration_ns");
            pW3.println("average_duration_ns,average_metric_1,average_metric_2");

            for (int i = 0; i < 100; i++) {

                int count = 0;
                long countTime = 0;
                int countMetric1 = 0;
                double countMetric2 = 0.0;

                while (count < repetitions) {

                    ArrayList<Integer> randomList = exp.generateList(size, value);

                    long start = System.nanoTime();
                    qSort.sort(randomList);
                    long end = System.nanoTime();
                    long time = end - start;

                    int outOfOrderPairs = exp.getOutOfOrderedPairs(randomList); //Finds out the amount of adjacent pairs out of order. Adjacent inversion.
                    double result = exp.calculateMetric2(randomList); // calculates the sum of the difference between an elements index in the sorted list to an unsorted list.
                    
                    pW.println(outOfOrderPairs + "," + time);
                    pW2.println(result + "," + time);

                    countTime += time;
                    countMetric1 += outOfOrderPairs;
                    countMetric2 += result;

                    count++;
                    
                }

                long averageTime = (long) countTime / repetitions;
                int averageMetric1 = (int) countMetric1 / repetitions;
                double averageMetric2 = (double) countMetric2 / repetitions;

                pW3.println(averageTime + "," + averageMetric1 + "," + averageMetric2);

                value += 10; 
                value = Math.round(value * 100.0) / 100.0;
                System.out.println(value);
            }

            pW.close();
            pW2.close();
            pW3.close();

        } catch (IOException e) {
            System.err.println(e.getMessage());
        }

    }

    /**
     * Generates the random list.
     * @param size - the size of the list.
     * @param degreeOfUnsortedness - a value determining how unsorted the list is.
     * @param swaps - is the amount of random swaps that are done. This is generated by halving the degreeOfUnsortedness.
     * @return - the created random list.
     */

    public ArrayList<Integer> generateList(int size, double degreeOfUnsortedness) {

        ArrayList<Integer> list = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) { //creates completely sorted list 
            list.add(i);
        }

        if (degreeOfUnsortedness == 0)  return list; 
       
        int swaps = (int) degreeOfUnsortedness / 2;

        for (int i = 0; i < swaps; i++) {
            int r1 = randomNumber(size);
            int r2 = randomNumber(size);
            while (r1 == r2) { // to make sure they aren't the same value
                r2 = randomNumber(size);
            }
            Collections.swap(list, r1, r2); //swaps the two random values of the list
        }
    
        return list;

    }

    /**
     * Picks a random number between 0 and size.
     * @param size - the upper limit of the random number to be chosen.
     * @return - the random number.
     */

    public int randomNumber (int size) {
         int value = (int) (Math.random()*(size - 0)); 
         return value;
    }

    /**
     * Calculates the amount of adjacent pairs that are out of order.
     * @param list - the list for the value to be calculated for.
     * @return - the amount of adjacent elements / pairs that are out of order.
     */

    public int getOutOfOrderedPairs(ArrayList<Integer> list) {
        int count = 0;
        for (int i = 0; i < list.size() - 1; i++) {
            if (list.get(i) > list.get(i+1)) {
                count++;
            }
        }
        return count;
    }

    /**
     * Calculates the value of metric 2.
     * Metric 2 - the sum that each index is out of place compared to where it should be. 
     * @param list - the list fo calculate the metric for.
     * @return - the total value calculated. The result is divided by the size and multiplied by 2 so that the value is easily able to be
     * compared to the values from the other metric.
     */
    public double calculateMetric2(ArrayList<Integer> list) {
        double result = 0.0;
        int count = 0;

        for (int i = 0; i < list.size(); i++) {
            int temp = (i + 1) - list.get(i);
            if (temp < 0) {
                temp = temp * -1;
            }
            count += temp;
        }

        result = (double) count * 2 / size;
        return result;

    }

    

    
}
